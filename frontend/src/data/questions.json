{
    "categories": [
        {
            "id": "sorting",
            "name": "Sorting",
            "description": "Sorting algorithms and related problems"
        },
        {
            "id": "recursion",
            "name": "Recursion",
            "description": "Recursive problem solving techniques"
        },
        {
            "id": "trees",
            "name": "Trees",
            "description": "Binary trees, BSTs, and tree traversals"
        },
        {
            "id": "graphs",
            "name": "Graphs",
            "description": "Graph algorithms and traversals"
        },
        {
            "id": "dynamic-programming",
            "name": "Dynamic Programming",
            "description": "Optimization problems using DP"
        },
        {
            "id": "others",
            "name": "Others",
            "description": "Miscellaneous algorithmic problems"
        }
    ],
    "questions": {
        "sorting": [],
        "recursion": [],
        "trees": [
            {
                "id": "binary-tree-inorder",
                "title": "Binary Tree Inorder Traversal",
                "category": "trees",
                "code": "# Binary Tree Inorder Traversal\n\n\"\"\"\nGiven the root of a binary tree, return the inorder traversal of its nodes' values.\n\nExample 1:\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversal(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[int]\n    \"\"\"\n    # Your code here\n    pass"
            },
            {
                "id": "maximum-depth-binary-tree",
                "title": "Maximum Depth of Binary Tree",
                "category": "trees",
                "code": "# Maximum Depth of Binary Tree\n\n\"\"\"\nGiven the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    # Your code here\n    pass"
            },
            {
                "id": "validate-binary-search-tree",
                "title": "Validate Binary Search Tree",
                "category": "trees",
                "code": "# Validate Binary Search Tree\n\n\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBST(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    # Your code here\n    pass"
            },
            {
                "id": "binary-tree-level-order",
                "title": "BFS",
                "category": "trees",
                "code": "# Binary Tree Level Order Traversal (BFS)\n\n\"\"\"\n- Task: level-order traversal  \n  - top→bottom  \n  - left→right  \n- Node: TreeNode(val,left,right)\n- Example  \n  - Tree  \n        3\n       / \\\n      9  20\n         / \\\n        15  7\n  - Output [[3],[9,20],[15,7]]\n\"\"\"\nfrom typing import List\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def levelOrder(self, root) -> List[List[int]]:\n        # TODO: implement\n        pass"
            },
            {
                "id": "binary-tree-level-order-bottom",
                "title": "BFS (Bottom Up)",
                "category": "trees",
                "code": "# Binary Tree Level Order Traversal II (BFS Bottom Up)\n\n\"\"\"\n- Task: level-order traversal  \n  - bottom→top  \n  - left→right  \n- Node: TreeNode(val,left,right)\n- Example  \n  - Tree  \n        3\n       / \\\n      9  20\n         / \\\n        15  7\n  - Output [[15,7],[9,20],[3]]\n\"\"\"\nfrom typing import List\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def levelOrderBottom(self, root) -> List[List[int]]:\n        # TODO: implement\n        pass"
            }
        ],
        "graphs": [],
        "dynamic-programming": [],
        "others": [
            {
                "id": "two-sum",
                "title": "Two Sum",
                "category": "others",
                "code": "# Two Sum\n\n\"\"\"\nGiven an array of integers nums and an integer target,\nreturn indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\"\"\"\n\ndef twoSum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    # Your code here\n    pass"
            }
        ]
    }
}